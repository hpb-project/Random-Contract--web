<template >
    <div id="content" class="main-content">
        <div id="privacyWrapper" class="">
            <div class="privacy-container">
                <div class="privacyContent"> 
                    <div class="d-flex justify-content-between privacy-head">
                        <div class="privacyHeader">
                            <h1 v-if="getLanguage=='en'">HRG Introduction</h1> 
                            <h1 v-else>HRG 介绍</h1> 
                        </div> 
                    </div>

                    <div  v-if="getLanguage=='en'" class="privacy-content-container">
                        <section>
                            <h5>HRG (HPB Random Generator)</h5>
                            <p class="text2em">HRG (HPB Random Generator) is a provably fair and verifiable random number generator based on smart contracts that can access random values without compromising security and usability. For each request, HRG will return a random number, which can be verified before the consumer contract uses it to ensure that it will not be tampered with or manipulated by the Oracle system and any committer.</p>
                        </section>
                        <section> 
                            <h5>Principle of Random Number Generation</h5> 
                            <p  class="text2em">
                                There are two roles in the HRG system, the committer - the producer of random numbers; and the consumer - the user of random numbers.
                            </p>
                            <p class="text2em"> 
                                A random number from the HRG system is generated by two submissions the committer submitted separately.
                            </p>
                            <ol class="ml-2"> 
                                <li class="text-center">
                                   <p class="text-left">The committer prepares a seed and obtains the hash of the seed (SeedHash) through the contract method.</p>
                                    <img src="assets/docimg/1.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p class="text-left">The committer performs the first submission, committing the SeedHash to the Oracle, which is stored as commits.</p>
                                       <img src="assets/docimg/2.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p  class="text-left">
                                        After a period of time (within 100000 blocks), the committer performs the second submission and commits the Seed to the Oracle. The Oracle recalculates the SeedHash and compares it with that of the first submission. After the verification is passed, the Seed is legal and can be used after.
                                    </p>
                                     <img src="assets/docimg/3.png" width="500" alt="">
                                </li> 
                            </ol> 
                            <p  class="text2em">
                                When HRG consumers need random numbers, they call Oracle's requestRandom interface to request random numbers.
                                 The Oracle contract selects unrevealed commits from the stored commits and binds them to consumers. 
                                 When the committer executes the reveal on this commit and passes the verification, 
                                 the Oracle contract will call the responseRandom method of the consumer contract,
                                  and use the Seed to generate a random number and send it to the consumer.     
                            </p>
                            <p  class="text2em">The overall process is as follows: </p>
                            <p class="text-center">
                                  <img src="assets/docimg/4.png" width="700" alt="">
                            </p>
                        </section> 
                        <section> 
                            <h5>Instructions</h5>
                            <p class="text2em">1. How to Submit Random Numbers</p>
                            <p class="ml-2">
                                HRG's Oracle contract provides three interfaces: gethash, 
                                commit and reveal to help users calculate the SeedHash and complete the operations of submission and verification.
                            </p>
                            <ul class="ml-3">
                                <li>
                                    <p>
                                        The committer first needs to generate a random 32-byte seed Seed and call the gethash method to obtain the hash.
                                    </p>
                                </li>  
                                <li>
                                    <p>
                                        The committer calls the commit method to submit the hash, and the Oracle contract will charge the 100 HRG as a deposit.
                                    </p>
                                </li> 
                                <li>
                                    <p>
                                        The second submission is completed within 1~1000 blocks after the first commit is successful, that is, the first step is to call the reveal method to submit the Seed generated in the first step.
                                    </p>
                                </li> 
                                 <li>
                                    <p>
                                        After completing the third step, the Oracle contract will return the deposit paid in the second step and the committer will receive the mining reward of the system. If this record is subscribed by the consumer, the subscriber's handling fee will also be given to the committer as revenue.
                                    </p>
                                </li>
                            </ul>
                            <p class="ml-2">
                               If the user submits random numbers using a dApp, the above steps will all be completed by the dApp. If the developer uses nodejs to develop the dApp by himself, the code for the above steps is as follows: 
                            </p>
                            <pre class="undefined">
            function genrandom() {
                const hexString = Array(64)
                .fill()
                .map(() => Math.round(Math.random() * 0xF).toString(16)
                .join('');
                return '0x'+hexString
            }
            async function CommitAndReveal(contractMap) {
                var tokenAddr     = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09";
                var depositAddr   = "0xd834452287dcCF0cf40F14CF252E593bC9191a78";
                var configAddr    = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986";
                var oracleAddr    = "0x800B5105b31bD100bE85E8646f86EA263aDB1786";
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                const oracle = await hre.ethers.getContractAt("Oracle", oracleAddr);
                // step1. generate random seed and compute hash.
                var seed = genrandom();
                var hash = await oracle.getHash(seed);
                console.log("hash is", hash,"seed is", seed);
                // step2. compute seed hash and call commit.
                // need approve hrg token to deposit contract.
                var depositAmount = await config.getDepositAmount();
                var depositwei = web3.utils.toWei(depositAmount.toString(), 'wei').toString();
                var t = await token.approve(depositAddr, depositwei);
                await t.wait();
                // call commit.
                var tx = await oracle.commit(hash);
                await tx.wait();
                console.log("commit succeed");
                // wait some time.
                var duration = 100000;
                sleep(duration);
                // step3. reveal with seed.
                tx = await oracle.reveal(hash, seed, {gasLimit:10000000});
                await tx.wait();
                console.log("reveal succeed");
            }

                            </pre>
                            <p class="ml-2">
                                Here is a complete runnable example of submitting random numbers. Before the execution, please ensure that there are enough HRG Tokens in the account to execute.
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // Manually modify PRIVATE_KEY in runcommiter.sh and fill in the private key of the execution account.
            # ./runcommiter.sh
                            </pre>
                           
                            <p class="text2em">2. How to Use Random Numbers</p>
                            <p class="ml-2">
                                HRG's Oracle contract provides the requestRandom interface for developers to obtain random numbers. However,
                                 this is not an interface that can get a random number immediately, but a subscription operation. 
                                 When the random number producer/ submits the random number seed, 
                                the responseRandom interface of the developer's current contract will be called to transmit the random number.
                            </p> 
                            <p class="ml-2">
                               A demo using SRNG random numbers.
                            </p>
                            <pre>
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.0;
            interface IOracle {
                function requestRandom(address,address) external returns (bool);
            }
            contract ComsumerExample {
                // Permissions used to control contract private operations
                address private _owner;
                modifier onlyOwner() {
                    require(_owner == msg.sender, "Ownable: caller is not the owner");
                    _;
                }
                IOracle oracle = IOracle(0x800B5105b31bD100bE85E8646f86EA263aDB1786); // oracle contract address
                constructor() {
                    _owner = msg.sender; // Set the deployer of the contract to owner)
                }

                // used to store random numbers
                uint256 _nrandom;      
                // responseRandom Used to receive random numbers, stored using _nrandom.
                function responseRandom(bytes32 commit, bytes32 random) public returns (bool) {
                    _nrandom = uint256(random);
                    return true;
                }
                address [] players;     //  Contract business logic, store users participating in the game.

                function startNewGame() public onlyOwner {      //  Start the game, private operation, can only be called by the contract owner
                    //  Request a random number. The first parameter is the transaction initiator, and the second parameter is the current contract address.
                    oracle.requestRandom(msg.sender, address(this));
                }
                //  Contract business logic, any user can participate in the game
                function joinGame() public {
                    players.push(msg.sender);
                }
                // The business logic of the contract, when the random number is obtained, end the game and use the random numbers to calculate the winner.
                function endGame() public onlyOwner {
                    require(_nrandom != 0, "not got random");
                    require(players.length > 0, "have no players");
                    uint32 wineridx = uint32(_nrandom% players.length);
                    emit GameWinner(players[wineridx], block.number);
                }
                event GameWinner(address winner, uint256 block); //  contract business event
            }

                            </pre>
                            <p class="ml-2">
                               After the contract is deployed, the startGame calling the contract will subscribe to random numbers, 
                               but this method will be charged a certain amount of HRG Token as a handling fee. 
                               Therefore, token authorization needs to be performed first. The sample code is as follows:
                            </p>
                            <pre>
            async function doSubscribe(consumerContract) {
                var deposit     = "0xd834452287dcCF0cf40F14CF252E593bC9191a78"; // deposit contract address on mainnet.
                var tokenAddr   = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09"; // hrgtoken contract address on mainnet.
                var configAddr  = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986"; // config contract address on mainnet.
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                var fee = await config.getFee();
                console.log("approve fee to deposit");
                var r = await token.approve(deposit, fee);
                await r.wait();
                var start = await consumerContract.startNewGame();
                await start.wait();
                console.log("start game and subscribe succeed");
            }

                            </pre>
                            <p class="ml-2">
                                Here is a complete example of a running consumer contract. 
                                Before the execution, please make sure that there are enough HRG Tokens in the account to execute. 
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // Manually modify PRIVATE_KEY in runconsume.sh and fill in the private key of the execution account.  
            # ./runconsume.sh

                            </pre>
                        </section>
                            
                        <section>
                            <h5>HRG Economy Model</h5>
                            <p class="text2em">
                                HRG issues HRG Token as the circulating currency of the system, with a total of 100 million issued.
                            </p> 
                        </section> 
                        
                         <section>
                            <h5>Token Allocation</h5>
                            <ul class="ml-2">
                                <li><p>50% generated through mining</p> </li>
                                <li><p>20% for raising funds</p></li>
                                <li><p>15% for developer community events</p></li>
                                <li><p>5% for airdrop activities</p></li>
                                <li><p>10% is allocated to the project team, 10% is initially released, and the rest is released in 3 years</p></li>
                            </ul>
                        </section>

                           
                        <section>
                            <h5> Mining Reward Algorithm</h5>
                            <p class="text2em"> Users can get mining rewards for participating in the submission of random numbers.</p>
                             <ul class="ml-2">
                                <li><p>In the initial stage, after the user completes the Seed verification, a reward of 100 HRG will be given;</p> </li>
                                <li><p>When the reward amount reaches 50% of the remaining total, the reward will start to be halved;</p></li> 
                            </ul>
                             <p class="text2em"> Example: When the total reward reaches 25 million,
                                  each reward will be 50 HRG; when the total reward reaches 37.5 million, each reward will be 25HRG.</p>
                        </section>

                    

                        <section>
                            <h5> Limitations</h5>
                            <p class="text2em">
                                In order to maintain the healthy development of the system, the following restrictions are imposed on users' operations:
                            </p>
                            <ul class="ml-2">
                                <li><p>Duplicated seeds and SeedHashes mustn’t be provided</p></li>
                                <li><p>There must be at least 1 block between the first-phase submission and the second-phase verification</p></li>
                                <li><p>One committer can only have up to 10 unverified commits, and no new commits can be submitted after reaching them</p></li>
                                <li><p>Commits after 1000 blocks can no longer be verified</p></li>
                            </ul>
                        </section>
                    </div>

                     <div  v-else class="privacy-content-container">
                        <section>
                            <h5>HRG (HPB Random Generator)</h5>
                            <p class="text2em">HRG (HPB Random Generator) 是基于智能合约实现的一个可证明公平和可验证的随机数生成器，智能合约能够访问随机值，而不损害安全性和可用性。对于每个请求，HRG 会反馈一个随机数，在消费合约使用它之前，可以进行随机数值的验证，确保不会被Oracle系统以及任何提交者篡改或操纵。</p>
                        </section>  
                        <section> 
                            <h5>随机数生成原理</h5> 
                            <p  class="text2em">HRG 系统中有两个角色，提交者-随机数的制造者；消费者-随机数的使用者。HRG系统的随机数由提交者分两次提交产生。</p>
                            <ol class="ml-2"> 
                                <li class="text-center">
                                   <p class="text-left"> 提交者准备一个种子，通过合约方法获得种子的哈希.</p>
                                    <img src="assets/docimg/1.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p class="text-left">提交者执行第一次提交，将种子哈希提交到Oracle，Oracle存储为commits.</p>
                                       <img src="assets/docimg/2.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p  class="text-left">在之后的一段时间内，提交者执行第二次提交，将种子提交到Oracle，Oracle重新计算种子的哈希与第一次提交的哈希进行比较验证，验证通过后，种子合法可被使用。</p>
                                     <img src="assets/docimg/3.png" width="500" alt="">
                                </li> 
                            </ol> 
                            <p  class="text2em">HRG的消费者需要随机数时，调用Oracle的requestRandom接口请求随机数。Oracle合约从存储的commits中挑选未经过reveal的commit与消费者进行绑定。当提交者对此条commit执行reveal并通过验证后，Oracle合约会调用消费者合约的responseRandom方法，使用种子生成随机数传送给消费者。</p>
                            <p  class="text2em">整体流程如下图：</p>
                            <p class="text-center">
                                  <img src="assets/docimg/4.png" width="700" alt="">
                            </p>
                        </section> 
                        <section> 
                            <h5>使用说明</h5>
                            <p class="text2em">1. 提交者如何提交随机数</p>
                            <p class="ml-2">
                                HRG 的 Oracle 合约提供了gethash, commit 和 reveal 三个接口帮助用户计算种子哈希并完成提交和验证的操作。
                            </p>
                            <ul class="ml-3">
                                <li>
                                    <p>提交者首先需要生成一个随机的32字节的种子seed，调用gethash 方法获得hash。</p>
                                </li>  
                                <li>
                                    <p>调用commit 方法提交hash，同时会Oracle合约会收取提交者 100 HRG 作为押金。</p>
                                </li> 
                                <li>
                                    <p>在commit成功后的1~1000个区块内完成二次提交，也就是将第一步调用reveal方法将第一步产生的seed提交。</p>
                                </li> 
                                 <li>
                                    <p>完成第三步之后，Oracle合约会返还第二步缴纳的押金，并获得系统的挖矿奖励。如果在Reveal的时候，此条Commit已经被消费者订阅，在Reveal成功后提交者还会收到消费者的订阅手续费作为收益。</p>
                                </li>
                            </ul>
                            <p class="ml-2">
                                如果用户使用dApp提交随机数，上述步骤全部由dApp完成，如果开发者使用nodejs自己开发dApp，上述步骤代码如下：
                            </p>
                            <pre class="undefined">
            function genrandom() {
                const hexString = Array(64)
                .fill()
                .map(() => Math.round(Math.random() * 0xF).toString(16)
                .join('');
                return '0x'+hexString
            }
            async function CommitAndReveal(contractMap) {
                var tokenAddr     = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09";
                var depositAddr   = "0xd834452287dcCF0cf40F14CF252E593bC9191a78";
                var configAddr    = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986";
                var oracleAddr    = "0x800B5105b31bD100bE85E8646f86EA263aDB1786";
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                const oracle = await hre.ethers.getContractAt("Oracle", oracleAddr);
                // step1. generate random seed and compute hash.
                var seed = genrandom();
                var hash = await oracle.getHash(seed);
                console.log("hash is", hash,"seed is", seed);
                // step2. compute seed hash and call commit.
                // need approve hrg token to deposit contract.
                var depositAmount = await config.getDepositAmount();
                var depositwei = web3.utils.toWei(depositAmount.toString(), 'wei').toString();
                var t = await token.approve(depositAddr, depositwei);
                await t.wait();
                // call commit.
                var tx = await oracle.commit(hash);
                await tx.wait();
                console.log("commit succeed");
                // wait some time.
                var duration = 100000;
                sleep(duration);
                // step3. reveal with seed.
                tx = await oracle.reveal(hash, seed, {gasLimit:10000000});
                await tx.wait();
                console.log("reveal succeed");
            }

                            </pre>
                            <p class="ml-2">这里有完整的可运行的提交随机数示例，在执行前，请先确保执行的账户中有足够的HRG Token.</p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // 手动修改 runcommiter.sh 中的 PRIVATE_KEY 填入执行账户的私钥. 
            # ./runcommiter.sh
                            </pre>
                           
                            <p class="text2em">2. 消费者如何使用随机数</p>
                            <p class="ml-2">
                                HRG 的 Oracle 合约提供了 requestRandom 接口用于开发者获取随机数。但是这不是能够立刻获得随机数的接口，而是预订的操作。当随机数的生产者/提交者提交随机数种子时，将会调用开发者当前合约的 responseRandom 接口，将随机数传送过来。
                            </p> 
                            <p class="ml-2">
                               下面是一个使用SRNG随机数的示例。
                            </p>
                            <pre>
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.0;
            interface IOracle {
                function requestRandom(address,address) external returns (bool);
            }
            contract ComsumerExample {
                // 用于控制合约私有操作的权限
                address private _owner;
                modifier onlyOwner() {
                    require(_owner == msg.sender, "Ownable: caller is not the owner");
                    _;
                }
                IOracle oracle = IOracle(0x800B5105b31bD100bE85E8646f86EA263aDB1786); // oracle contract address
                constructor() {
                    _owner = msg.sender; // 将合约的部署者设置为 owner
                }

                // 用于存储随机数 (Translation: // used to store random numbers)
                uint256 _nrandom;      
                // responseRandom 用于接收随机数, 使用 _nrandom 存储下来. 
                function responseRandom(bytes32 commit, bytes32 random) public returns (bool) {
                    _nrandom = uint256(random);
                    return true;
                }
                address [] players;     // 合约业务逻辑，存储参与游戏的用户

                function startNewGame() public onlyOwner {      // 开始比赛，私有操作，只能合约owner调用 
                    // 请求随机数. 第一个参数为交易发起者，第二个参数为当前合约地址. 
                    oracle.requestRandom(msg.sender, address(this));
                }
                // 合约业务逻辑，任何用户都可以参加游戏 
                function joinGame() public {
                    players.push(msg.sender);
                }
                // 合约业务逻辑，当获得了随机数后，结束比赛，并使用随机数计算获胜者.
                function endGame() public onlyOwner {
                    require(_nrandom != 0, "not got random");
                    require(players.length > 0, "have no players");
                    uint32 wineridx = uint32(_nrandom% players.length);
                    emit GameWinner(players[wineridx], block.number);
                }
                event GameWinner(address winner, uint256 block); // 合约业务事件 
            }

                            </pre>
                            <p class="ml-2">
                               合约部署后，调用合约的 startGame 会订阅随机数，但是此方法会被收取一定数量的 HRG Token 作为手续费，因此，需要先进行 token 授权, 示例代码如下:
                            </p>
                            <pre>
            async function doSubscribe(consumerContract) {
                var deposit     = "0xd834452287dcCF0cf40F14CF252E593bC9191a78"; // deposit contract address on mainnet.
                var tokenAddr   = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09"; // hrgtoken contract address on mainnet.
                var configAddr  = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986"; // config contract address on mainnet.
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                var fee = await config.getFee();
                console.log("approve fee to deposit");
                var r = await token.approve(deposit, fee);
                await r.wait();
                var start = await consumerContract.startNewGame();
                await start.wait();
                console.log("start game and subscribe succeed");
            }

                            </pre>
                            <p class="ml-2">
                                这里有完整的可运行的消费合约示例，在执行前，请先确保执行的账户中有足够的HRG Token.
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // 手动修改 runconsume.sh 中的 PRIVATE_KEY 填入执行账户的私钥.  
            # ./runconsume.sh

                            </pre>
                        </section>
                            
                        <section>
                            <h5> HRG 经济模型</h5>
                           <p class="text2em">HRG 发行 HRG Token 作为系统的流通货币，总量发行 100,000,000 枚.</p> 
                        </section> 
                        
                         <section>
                            <h5> Token 分配 </h5>
                            <ul class="ml-2">
                                <li><p>50% 通过挖矿产出</p> </li>
                                <li><p>20% 用于募集资金</p></li>
                                <li><p>15% 用于开发者社区活动</p></li>
                                <li><p>5% 用于空投活动</p></li>
                                <li><p>10% 分配给项目团队，初始释放 10%，剩余部分分3年释放完</p></li>
                            </ul>
                        </section>

                           
                        <section>
                            <h5> 挖矿奖励算法.</h5>
                            <p class="text2em"> 用户参与提交随机数都可以获得挖矿奖励.</p>
                             <ul class="ml-2">
                                <li><p>初始阶段，用户完成种子验证之后，给与 100 HRG奖励；</p> </li>
                                <li><p>当奖励数量每达到剩余总量的50%时，奖励开始减半; </p></li> 
                            </ul>
                             <p class="text2em"> 举例说明：当总奖励数达到 25,000,000 之后，每次奖励 50 HRG； 当奖励总数达到 37,500,000 后，每次奖励 25HRG。</p>
                        </section>

                    

                        <section>
                            <h5> 局限性</h5>
                            <p class="text2em">   为了维护系统的健康发展，对用户的操作有以下几项限制：</p>
                              <ul class="ml-2">
                                <li><p>不可提供重复的种子和种子哈希</p></li>
                                <li><p>第一阶段提交和第二阶段验证之间至少要间隔1个区块</p></li>
                                <li><p>提交者最多只能有10个未验证的Commit存在，达到之后不能再提交新的Commit</p></li>
                                <li><p>超过1000个区块之后的Commit无法再进行验证</p></li>
                            </ul>
                        </section>
                    </div>


                </div>
            </div>
        </div>
        <Footer></Footer> 
    </div>
</template>
<script>
import Footer from '../components/Footer.vue';
export default {
    name: "DocumentPage",
    components: { Footer },
    computed: {
        getLanguage() {
            return this.$i18n.locale;
        }, 
    },
    watch: {
        getLanguage: { 
        handler: function (newval) {
            const that = this;
            if (that.table) {
            $(that.mySubmitTableName).dataTable().fnDestroy();
            that.initTable(this.mySubmitList); 
            }
        },
        },
    }
}
</script>
<style >
    
</style>