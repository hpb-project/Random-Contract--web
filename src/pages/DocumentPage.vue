<template >
    <div id="content" class="main-content">
        <div id="privacyWrapper" class="">
            <div class="privacy-container">
                <div class="privacyContent"> 
                    <div class="d-flex justify-content-between privacy-head">
                        <div class="privacyHeader">
                            <h1 v-if="getLanguage=='en'">HRG Introduction</h1> 
                            <h1 v-else>HRG 介绍</h1> 
                        </div> 
                    </div>

                    <div  v-if="getLanguage=='en'" class="privacy-content-container">
                        <section>
                            <h5>HRG (HPB Random Generator)</h5>
                            <p class="text2em">HRG (HPB Random Generator) is a provably fair and verifiable random number generator based on smart contracts that can access random values without compromising security and usability. For each request, HRG will return a random number, which can be verified before the consumer contract uses it to ensure that it will not be tampered with or manipulated by the Oracle system and any committer.</p>
                        </section>
                        <section> 
                            <h5>Principle of Random Number Generation</h5> 
                            <p  class="text2em">
                                There are two roles in the HRG system, the committer - the producer of random numbers; and the consumer - the user of random numbers.
                            </p>
                            <p class="text2em"> 
                                A random number from the HRG system is generated by two submissions the committer submitted separately.
                            </p>
                            <ol class="ml-2"> 
                                <li class="text-center">
                                   <p class="text-left">The committer prepares a seed and obtains the hash of the seed (SeedHash) through the contract method.</p>
                                    <img src="assets/docimg/1.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p class="text-left">The committer performs the first submission, committing the SeedHash to the Oracle, which is stored as commits.</p>
                                       <img src="assets/docimg/2.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p  class="text-left">
                                        After a period of time (within 100000 blocks), the committer performs the second submission and commits the Seed to the Oracle. The Oracle recalculates the SeedHash and compares it with that of the first submission. After the verification is passed, the Seed is legal and can be used after.
                                    </p>
                                     <img src="assets/docimg/3.png" width="500" alt="">
                                </li> 
                            </ol> 
                            <p  class="text2em">
                                When HRG consumers need random numbers, they call Oracle's requestRandom interface to request random numbers.
                                 The Oracle contract selects unrevealed commits from the stored commits and binds them to consumers. 
                                 When the committer executes the reveal on this commit and passes the verification, 
                                 the Oracle contract will call the responseRandom method of the consumer contract,
                                  and use the Seed to generate a random number and send it to the consumer.     
                            </p>
                            <p  class="text2em">The overall process is as follows: </p>
                            <p class="text-center">
                                  <img src="assets/docimg/4.png" width="700" alt="">
                            </p>
                        </section> 
                        <section> 
                            <h5>Instructions</h5>
                            <p class="text2em">1. How to Submit Random Numbers</p>
                            <p class="ml-2">
                                HRG's Oracle contract provides three interfaces: gethash, 
                                commit and reveal to help users calculate the SeedHash and complete the operations of submission and verification.
                            </p>
                            <ul class="ml-3">
                                <li>
                                    <p>
                                        The committer first needs to generate a random 32-byte seed Seed and call the gethash method to obtain the hash.
                                    </p>
                                </li>  
                                <li>
                                    <p>
                                        The committer calls the commit method to submit the hash, and the Oracle contract will charge the 100 HRG as a deposit.
                                    </p>
                                </li> 
                                <li>
                                    <p>
                                        The second submission is completed within 1~1000 blocks after the first commit is successful, that is, the first step is to call the reveal method to submit the Seed generated in the first step.
                                    </p>
                                </li> 
                                 <li>
                                    <p>
                                        After completing the third step, the Oracle contract will return the deposit paid in the second step and the committer will receive the mining reward of the system. If this record is subscribed by the consumer, the subscriber's handling fee will also be given to the committer as revenue.
                                    </p>
                                </li>
                            </ul>
                            <p class="ml-2">
                               If the user submits random numbers using a dApp, the above steps will all be completed by the dApp. If the developer uses nodejs to develop the dApp by himself, the code for the above steps is as follows: 
                            </p>
                            <pre class="undefined">
            function genrandom() {
                const hexString = Array(64)
                .fill()
                .map(() => Math.round(Math.random() * 0xF).toString(16)
                .join('');
                return '0x'+hexString
            }
            async function CommitAndReveal(contractMap) {
                var tokenAddr     = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09";
                var depositAddr   = "0xd834452287dcCF0cf40F14CF252E593bC9191a78";
                var configAddr    = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986";
                var oracleAddr    = "0x800B5105b31bD100bE85E8646f86EA263aDB1786";
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                const oracle = await hre.ethers.getContractAt("Oracle", oracleAddr);
                // step1. generate random seed and compute hash.
                var seed = genrandom();
                var hash = await oracle.getHash(seed);
                console.log("hash is", hash,"seed is", seed);
                // step2. compute seed hash and call commit.
                // need approve hrg token to deposit contract.
                var depositAmount = await config.getDepositAmount();
                var depositwei = web3.utils.toWei(depositAmount.toString(), 'wei').toString();
                var t = await token.approve(depositAddr, depositwei);
                await t.wait();
                // call commit.
                var tx = await oracle.commit(hash);
                await tx.wait();
                console.log("commit succeed");
                // wait some time.
                var duration = 100000;
                sleep(duration);
                // step3. reveal with seed.
                tx = await oracle.reveal(hash, seed, {gasLimit:10000000});
                await tx.wait();
                console.log("reveal succeed");
            }

                            </pre>
                            <p class="ml-2">
                                Here is a complete runnable example of submitting random numbers. Before the execution, please ensure that there are enough HRG Tokens in the account to execute.
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // Manually modify PRIVATE_KEY in runcommiter.sh and fill in the private key of the execution account.
            # ./runcommiter.sh
                            </pre>
                           
                            <p class="text2em">2. How to Use Random Numbers</p>
                            <p class="ml-2">
                                HRG's Oracle contract provides the requestRandom interface for developers to obtain random numbers. However,
                                 this is not an interface that can get a random number immediately, but a subscription operation. 
                                 When the random number producer/ submits the random number seed, 
                                the responseRandom interface of the developer's current contract will be called to transmit the random number.
                            </p> 
                            <p class="ml-2">
                               A demo using SRNG random numbers.
                            </p>
                            <pre>
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.0;
            interface IOracle {
                function requestRandom(address,address) external returns (bool);
            }
            contract ComsumerExample {
                // Permissions used to control contract private operations
                address private _owner;
                modifier onlyOwner() {
                    require(_owner == msg.sender, "Ownable: caller is not the owner");
                    _;
                }
                IOracle oracle = IOracle(0x800B5105b31bD100bE85E8646f86EA263aDB1786); // oracle contract address
                constructor() {
                    _owner = msg.sender; // Set the deployer of the contract to owner)
                }

                // used to store random numbers
                uint256 _nrandom;      
                // responseRandom Used to receive random numbers, stored using _nrandom.
                function responseRandom(bytes32 commit, bytes32 random) public returns (bool) {
                    _nrandom = uint256(random);
                    return true;
                }
                address [] players;     //  Contract business logic, store users participating in the game.

                function startNewGame() public onlyOwner {      //  Start the game, private operation, can only be called by the contract owner
                    //  Request a random number. The first parameter is the transaction initiator, and the second parameter is the current contract address.
                    oracle.requestRandom(msg.sender, address(this));
                }
                //  Contract business logic, any user can participate in the game
                function joinGame() public {
                    players.push(msg.sender);
                }
                // The business logic of the contract, when the random number is obtained, end the game and use the random numbers to calculate the winner.
                function endGame() public onlyOwner {
                    require(_nrandom != 0, "not got random");
                    require(players.length > 0, "have no players");
                    uint32 wineridx = uint32(_nrandom% players.length);
                    emit GameWinner(players[wineridx], block.number);
                }
                event GameWinner(address winner, uint256 block); //  contract business event
            }

                            </pre>
                            <p class="ml-2">
                               After the contract is deployed, the startGame calling the contract will subscribe to random numbers, 
                               but this method will be charged a certain amount of HRG Token as a handling fee. 
                               Therefore, token authorization needs to be performed first. The sample code is as follows:
                            </p>
                            <pre>
            async function doSubscribe(consumerContract) {
                var deposit     = "0xd834452287dcCF0cf40F14CF252E593bC9191a78"; // deposit contract address on mainnet.
                var tokenAddr   = "0xaB06f2bEd629106236dA27fdc41E90654aD75C09"; // hrgtoken contract address on mainnet.
                var configAddr  = "0x4E3aa47E2a6ac00918Bd819294eCe17235EfA986"; // config contract address on mainnet.
                const token = await hre.ethers.getContractAt("HRGToken", tokenAddr);
                const config = await hre.ethers.getContractAt("Config", configAddr);
                var fee = await config.getFee();
                console.log("approve fee to deposit");
                var r = await token.approve(deposit, fee);
                await r.wait();
                var start = await consumerContract.startNewGame();
                await start.wait();
                console.log("start game and subscribe succeed");
            }

                            </pre>
                            <p class="ml-2">
                                Here is a complete example of a running consumer contract. 
                                Before the execution, please make sure that there are enough HRG Tokens in the account to execute. 
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // Manually modify PRIVATE_KEY in runconsume.sh and fill in the private key of the execution account.  
            # ./runconsume.sh

                            </pre>
                        </section>
                            
                        <section>
                            <h5>HRG Economy Model</h5>
                            <p class="text2em">
                                HRG issues HRG Token as the circulating currency of the system, with a total of 100 million issued.
                            </p> 
                        </section> 
                        
                         <section>
                            <h5>Token Allocation</h5>
                            <ul class="ml-2">
                                <li><p>50% generated through mining</p> </li>
                                <li><p>20% for raising funds</p></li>
                                <li><p>15% for developer community events</p></li>
                                <li><p>5% for airdrop activities</p></li>
                                <li><p>10% is allocated to the project team, 10% is initially released, and the rest is released in 3 years</p></li>
                            </ul>
                        </section>

                           
                        <section>
                            <h5> Mining Reward Algorithm</h5>
                            <p class="text2em"> Users can get mining rewards for participating in the submission of random numbers.</p>
                             <ul class="ml-2">
                                <li><p>In the initial stage, after the user completes the Seed verification, a reward of 100 HRG will be given;</p> </li>
                                <li><p>When the reward amount reaches 50% of the remaining total, the reward will start to be halved;</p></li> 
                            </ul>
                             <p class="text2em"> Example: When the total reward reaches 25 million,
                                  each reward will be 50 HRG; when the total reward reaches 37.5 million, each reward will be 25HRG.</p>
                        </section>

                    

                        <section>
                            <h5> Limitations</h5>
                            <p class="text2em">
                                In order to maintain the healthy development of the system, the following restrictions are imposed on users' operations:
                            </p>
                            <ul class="ml-2">
                                <li><p>Duplicated seeds and SeedHashes mustn’t be provided</p></li>
                                <li><p>There must be at least 1 block between the first-phase submission and the second-phase verification</p></li>
                                <li><p>One committer can only have up to 10 unverified commits, and no new commits can be submitted after reaching them</p></li>
                                <li><p>Commits after 1000 blocks can no longer be verified</p></li>
                            </ul>
                        </section>
                    </div>

                     <div  v-else class="privacy-content-container">
                        <section>
                            <h5>HRG (HPB Random Generator)</h5>
                            <p class="text2em">HRG (HPB Random Generator) 是基于智能合约实现的一个可证明公平和可验证的随机数生成器，使智能合约能够访问随机值，而不损害安全性和可用性。对于每个请求，HRG 会反馈一个随机数，在消费合约使用它之前，可以进行随机数值的验证，确保不会被Oracle系统以及任何提交者篡改或操纵。</p>
                        </section>  
                        <section> 
                            <h5>随机数生成原理</h5> 
                            <p  class="text2em">HRG 系统中有三个角色：</p>
                            <ul class="ml-2">
                                <li class="text-center">
                                   <p class="text-left">提交者：随机数的生产者，分两个阶段完成一个随机数种子的生成；</p> 
                                </li> 
                                <li class="text-center">
                                   <p class="text-left">消费者：订阅并使用随机数的用户，也称订阅者或使用者；</p> 
                                </li> 
                                <li class="text-center">
                                   <p class="text-left">Oracle：HRG合约系统，为提交者和消费者提供所有操作接口;</p> 
                                </li> 
                            </ul>
                            <p class="text2em">
                                提交者分两阶段生成一个随机种子，当消费者订阅随机数时，附带一个口令，Oracle 系统从未完成第二阶段提交的Commit中随机订阅一条给消费者并记录订阅口令。当提交者完成第二阶段提交后，消费者可通过订阅的种子哈希从Oracle查看订阅到的随机数。因为种子的提交对世界是公开的，而与之绑定的订阅口令是私密的，所以随机数是由种子与口令哈希计算产生。
                            </p>
                            <p  class="text2em">整个过程如下图：</p>
                             <p class="text-center">
                                  <img src="assets/docimg/flow-1.png" width="700" alt="">
                            </p>
                            <h5>提交者提交随机种子</h5> 
                            <p class="text2em">
                                HRG系统的随机数来源是提交者制造的随机种子，为了保证种子的不可预知性和可验证性，提交者分两个阶段完成一个种子的生成。
                            </p>
                            <ol class="ml-2"> 
                                <li class="text-center">
                                   <p class="text-left">提交者本地生成一个32字节种子，通过合约方法获得种子的哈希.</p>
                                    <img src="assets/docimg/1.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p class="text-left">提交者执行第一阶段提交，将种子哈希提交到Oracle，Oracle查重之后存储为commits，并且从HPB链上获取当前区块的真随机数存储到commits中作为备用。同时 Oracle 系统收取提交者 1 HRG 作为押金。</p>
                                       <img src="assets/docimg/2.png" width="500" alt="">
                                </li> 
                                <li class="text-center mt10">
                                    <p  class="text-left">至少间隔1个区块后，最多不超过200个区块，提交者执行第二阶段提交，将种子提交到Oracle，Oracle重新计算种子的哈希与第一阶段提交的哈希进行比较验证，验证通过后，种子提交完成，退还 1HRG质押金，并在HRG Token合约中铸造 1HRG作为奖励发送给提交者.</p>
                                     <img src="assets/docimg/3.png" width="500" alt="">
                                </li> 
                            </ol> 
                            <p class="text2em">
                                如果在第一阶段提交后超过200个区块没有执行第二阶段提交，那么Oracle将不再接受提交，罚没押金作为惩罚。当提交者累积的未验证记录达到一定数量后，提交者将无法再执行新的提交，只能切换其他账户。
                            </p>

                            <h5>消费者/订阅者订购和使用随机数</h5> 
                            <p class="text2em">
                                消费者通过Oracle系统的requestRandom接口订阅随机数，如果有可用Commit，则自动绑定订阅关系，同时收取 2 HRG作为手续费。
                            </p>
                            <p class="text2em">
                                提交者应当及时对被订阅的Commit执行第二阶段提交，完成第二阶段提交后，消费者可得到由提交者提交的种子产生的随机数；如果提交者超时未完成提交，那么消费者将得到以HPB链上真随机数作为种子产生的随机数。
                            </p>
                            <p class="text2em">
                                requestRandom允许传入两个账户地址，分别为扣费账户和消费账户。扣费账户提供手续费，订阅成功后可以查看订阅列表，扣费账户和消费账户都有权查看最终得到的随机数。消费账户通常使用需要使用随机数的合约地址。
                            </p>
                            <p class="text-center">
                                  <img src="assets/docimg/5.png" width="700" alt="">
                            </p> 
                        </section> 
                        <section> 
                            <h5>使用说明</h5>
                            <p class="text2em">1. 提交者如何提交随机数</p>
                            <p class="ml-3">
                                提交者可以在 https://rc.hpb.io 上进行手动提交，具体操作步骤见<a href="操作手册" target="_blank">操作手册</a>, 
                                也可以在服务器上运行robot 进行自动提交，具体教程见 <a href="https://github.com/hpb-project/srng-robot" target="_blank">robot操作手册</a>.
                            </p>
                               <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // 手动修改 runcommiter.sh 中的 PRIVATE_KEY 填入执行账户的私钥. 
            # ./runcommiter.sh
                            </pre>

                            <p class="text2em">
                                2. 消费者如何使用随机数
                            </p>
                            <p  class="ml-3">
                                消费者可以在 https://rc.hpb.io/purchase 上体验直接订阅随机数以及使用合约订阅随机数，还可以基于示例合约开发自己的合约来使用随机数。具体操作步骤见HRG订阅随机数操作手册。
                            </p>
                            <p class="ml-3">
                                  这里有完整的可运行的消费合约示例，在执行前，请先确保执行的账户中有足够的 HRG Token.
                            </p>
                            <pre>
            # git clone https://github.com/hpb-project/SRNG
            # cd SRNG
            # npm install
            # // 手动修改 runconsume.sh 中的 PRIVATE_KEY 填入执行账户的私钥. 
            # ./runconsume.sh
                            </pre> 
                        </section>
                            
                        <section>
                            <h5> HRG 经济模型</h5>
                           <p class="text2em">HRG 发行 HRG Token 作为系统的流通货币，总量发行 100,000,000 枚.</p> 
                        </section> 
                        
                         <section>
                            <h5> Token 分配 </h5>
                            <ul class="ml-2">
                                <li><p>50% 通过挖矿产出</p> </li>
                                <li><p>20% 用于募集资金</p></li>
                                <li><p>15% 用于开发者社区活动</p></li>
                                <li><p>5% 用于空投活动</p></li>
                                <li><p>10% 分配给项目团队，初始释放 10%，剩余部分分3年释放完</p></li>
                            </ul>
                        </section>

                           
                        <section>
                            <h5> 挖矿奖励算法.</h5>
                            <p class="text2em"> 用户参与提交随机数都可以获得挖矿奖励。</p>
                             <ul class="ml-2">
                                <li><p>初始阶段，用户完成种子验证之后，给与 1 HRG奖励；</p> </li>
                                <li><p>当奖励数量每达到剩余总量的50%时，奖励开始减半; </p></li> 
                            </ul>
                             <p class="text2em"> 举例说明：挖矿总数量为 50,000,000 HRG, 当奖励数达到 25,000,000 之后，每次奖励 0.5 HRG； 当奖励总数达到 37,500,000 后，每次奖励 0.25 HRG。</p>
                        </section>

                    

                        <section>
                            <h5> 局限性</h5>
                            <p class="text2em">   为了维护系统的健康发展，对用户的操作有以下几项限制：</p>
                              <ul class="ml-2">
                                <li><p>不可提供重复的种子和种子哈希</p></li>
                                <li><p>第一阶段提交和第二阶段验证之间至少要间隔1个区块</p></li>
                                <li><p>第二阶段提交必须在第一阶段提交之后的200个区块内完成，否则将不能执行第二次提交，质押金不予退回</p></li>
                                <li><p>提交者最多只能有100000个未验证的Commit存在，达到之后不能再提交新的Commit</p></li> 
                            </ul>
                        </section>
                    </div>


                </div>
            </div>
        </div>
        <Footer></Footer> 
    </div>
</template>
<script>
import Footer from '../components/Footer.vue';
export default {
    name: "DocumentPage",
    components: { Footer },
    computed: {
        getLanguage() {
            return this.$i18n.locale;
        }, 
    },
    watch: {
        getLanguage: { 
        handler: function (newval) {
            const that = this;
            if (that.table) {
            $(that.mySubmitTableName).dataTable().fnDestroy();
            that.initTable(this.mySubmitList); 
            }
        },
        },
    }
}
</script>
<style >
    
</style>